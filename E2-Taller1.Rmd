---
title: "TALLER: Tutorial R – Distribuciones muestrales e intervalos de confianza"
output: html_notebook
---

## 1. Funciones en R
Para construir funciones en R es necesario seguir la siguiente estructura:
```{r}
nombre_de_funcion <- function(par1, par2, ...) {
  cuerpo
  return(resultado)
}
```
Dichas funciones se pueden usar digitando su nombre seguido de los parámetros entre paréntesis, son usadas para encapsular código que se usará constantemente y a pesar de no retornar más de un valor, es posible crear una lista de diferentes salidas y retornarla, como se mostrará a continuación en el caso de la función iqr(v), que recibe como entrada un vector de valores numéricos y dentro calcula el primer y tercer cuartil (0.25 y 0.75) haciendo uso de la función predefinida de R, quantile, la cual recibe el vector, los valores de los cuantiles requeridos y se setea el parámetro names en falso para que solo se retorne el valor y no su porcentaje (por ejemplo, 25% y 75%). Luego se guardan los valores que se quieren retornar en una lista (usando list) haciendo una asignación de clave-valor que finalmente se retornará.

```{r}
values = c(7,5,9,2,1,8,3,4,6,10)
iqr <- function(v) {
  q1 = quantile(v,1/4,names = FALSE)
  q3 = quantile(v,3/4,names = FALSE)
  iqr_list=list("q1"=q1,"q3"=q3,"ext"=q3-q1)
  return (iqr_list);
}
iqr(values)
```

## 2. Distribuciones de probabilidad en R
### Describir la función de densidad de probabilidad, función de distribución acumulada y función cuantil
* **Funciones de densidad de probabilidad:** Las funciones de densidad de probabilidad describen la probabilidad de observar cierto valor dentro de una muestra dada. Estas funciones se dividen en distribuciones discretas y continuas; la primera solo toma valores positivos en un conjunto de posibles valores, mientras que la segunda acepta valores tanto positivos como negativos.
* **Función de distribución acumulada:** La función de distribución acumulada describe la probabilidad de que una variable dentro de una muestra obtenga un valor n.
* **Función cuantil de la distribución:** Se le conoce como la función inversa de la función de distribución acumulada, debido a que indica el valor de la variable aleatoria para el cual la probabilidad de que esa variable aleatoria sea menor o igual a dicho valor sea la probabilidad dada.

### ¿Qué funciones existen en R que permitan obtener valores asociadas a esas funciones?

Las funciones para la función de densidad, la función acumulativa y la función cuantil deben aplicarse sobre una distribución x, siendo **d**x, **p**x y **q**x respectivamente.

Estas distribuciones pueden ser:

#### Distribuciones Discretas:

**Binomial**: binom

**Poisson**: pois

**Geométrica**: geom

**Hipergeométrica**: hyper

**Binomial negativa**: nbinom

#### Distribuciones Continuas: 

**Uniforme**: unif

**Normal**: norm

**t student**: t

**F Fisher**: F

**Chi-Cuadrado**: chisq

**Exponencial**: exp

**Gamma**: gamma

**Weibull**: weibull

**W de Wilcoxon**: wilcox   


### Muestre estas funciones para 4 distribuciones de probabilidad diferentes (dos distribuciones de variables continuas y dos distribuciones de variables discretas). Use gráficas para visualizar dichas funciones.

#### Distribución Discreta

```{r setup}
x <- 1:80
par(mfrow = c(2, 3))
plot(dbinom(x, size = 80, prob = 0.2), type = "h", lwd = 2,
     main = "Densidad Binomial", ylab = "P(X = x)", xlab = "Número de éxitos", col = 'red')
plot(pbinom(x, size = 80, prob = 0.2), type = 'l',ylab = "P(X = x)",
     xlab = 'Número de éxitos', main = 'Acumulada Binomial', col = 'red')
plot(qbinom(seq(0, 1, 0.001), size = 80, prob = 0.2), type='l',lwd = 2,
     main = 'Cuantil Binomial', ylab = 'Número de éxitos', xlab = 'P(X = x)', col = 'red', xaxt = "n")
axis(1, labels = seq(0, 1, 0.1), at = 0:10 * 100)
lambda <- 5
plot(dpois(x, lambda), type = "h", lwd = 2,
     main = "Densidad Poisson",
     ylab = "P(X = x)", xlab = "Número de eventos", col = 'blue')
plot(ppois(x, lambda), type = "l", lwd = 2,
     main = "Acumulada Poisson",
     ylab = "P(X = x)", xlab = "Número de eventos", col = 'blue')
plot(qpois(seq(0, 1, 0.001), lambda), type = "l", lwd = 2,
     main = "Cuantil Poisson",
     ylab = "P(X = x)", xlab = "Número de eventos", col = 'blue', xaxt = "n")
axis(1, labels = seq(0, 1, 0.1), at = 0:10 * 100)

```
#### Distribución continua

```{r}
par(mfrow = c(2, 3))
x <- seq(-4, 8, 0.1)
plot(x,dnorm(x, mean = 0, sd = 1), type = "l",
     ylim = c(0, 0.6), lwd = 2, col = "green",
     main = 'Densidad Normal', xlab = 'Número de éxitos', ylab = 'P(X = x)')
plot(x,pnorm(x, mean = 0, sd = 1), type = 'l',
     col = "green",main = 'Normal Acumulada', xlab = 'Número de éxitos', ylab = 'P(X = x)')
plot(qnorm(seq(0, 1, 0.001), mean = 0, sd = 1),
     type = 'l', xaxt = "n", col = "green",main = 'Cuantil Normal', ylab = 'Número de éxitos', xlab = 'P(X = x)')
axis(1, labels = seq(0, 1, 0.1), at = 0:10 * 100)

plot(x,dt(x,df = 5), type = 'l', col = "orange",
     main = 'Densidad T', xlab = 'Número de éxitos', ylab = 'P(X = x)')
plot(x,pt(x,df = 5), type = 'l', col = "orange",
     main = 'T acumulada', xlab = 'Número de éxitos', ylab = 'P(X = x)')
plot(qt(seq(0, 1, 0.001),df = 5), type = 'l', xaxt = "n", col = "orange",
     main = 'Cuantil T', ylab = 'Número de éxitos', xlab = 'P(X = x)')
axis(1, labels = seq(0, 1, 0.1), at = 0:10 * 100)
```

## 3. Investigando la construcción de los intervalos de confianza con el lenguaje de programación R
Se hace uso de la función read.table de R, para leer el dataframe abalone.data (siendo .data el tipo de archivo), usando como separador a la coma y cuyo nombre interno será data (contiene 4177 registros y 9 columnas).
```{r}
data=read.table("abalone.data",sep=",")
```
Se crea la función principal: **mu_ci(x,dist,n_samples,n_obs,ci)**, la cual recibe como parámetros un vector **x** (que en este contexto serán los valores de la columna "length" del dataframe abalone), el caracter **dist** cuyo valor puede ser 't' o 'n' dependiendo de si se quiere muestrear siguiendo la distribucion t o la normal, **n_samples** hace referencia al número de muestras (que en este caso será siempre 10000), y **n_obs** almacena la cantidad de observaciones (que en este caso tomará valores de 20, 10 y 3), y **ci** se refiere al intervalo de confianza que se desea (0.9).

Internamente, en la función se halla la media poblacional **mu** del vector x, se inicializa un contador **cont**. Se guardan en la matriz **combined** el conjunto de todas las muestras (columnas) con sus respectivas observaciones (filas), haciendo uso de la función **sample()** para sacar una muestra con cierto tamaño **n_size** y la función **replicate()** para generar la cantidad **n_samples** de muestras, todo esto se repite hasta que no exista alguna columna donde todas sus filas tengan el mismo valor para procurar el correcto funcionamiento de **t.test()** para la obtención del intervalo de confianza en el caso de una distribución t de Student y de **confint()** para una distribución normal, se usa la función **lm()** como una forma de indicarle a la anterior función que se intenta aproximar a una distribución normal. Finalmente se retorna la fracción de las muestras donde la media poblacional **mu** se encuentra dentro de los intervalos de confianza respectivos (aumentando el contador cada vez que esto pasaba y diviendolo finalmente en el numero de muestras).
```{r}
mu_ci <- function(x,dist,n_samples,n_obs,ci){
  mu=mean(x);  cont=0;
  repeat{combined=replicate(n_samples,sample(x,size=n_obs))
    if(eq_in_row(combined)==0){break}}
  for (i in 1:n_samples){
    if (dist=='t'){
      z=t.test(combined[,i], conf.level = ci)
      if (mu>=z$conf.int[1] & mu<=z$conf.int[2]){cont=cont+1}}
    if(dist=='n'){
      z=confint(lm(combined[,i]~1),level=ci)
      if (mu>=z[1] & mu<=z[2]){cont=cont+1}}}
  return(cont/n_samples)
}
```

Se crea la funcion **eq_in_row(matrix)** para verificar que no exista alguna columna donde todas sus filas tengan el mismo valor. Haciendo uso de la función **unique()** que retorna un vector con los elementos duplicados de cada fila eliminados y se verfica con la función **length()** que su tamaño sea uno (que todos las columnas tengan el mismo valor) reproduciendo este proceso para cada columna mediante la función **apply()** y usará la función **sum()** para conocer la cantidad de columnas donde todos sus valores son iguales para retornar dicho valor **s** (aunque lo deseable es que este valor sea cero, para que no fallen las funciones **t.test()** ni **confint()**).
```{r}
eq_in_row <- function(matrix) {
  s=sum(apply(matrix, 2, function(a) length(unique(a))==1))
  return(s)
}
```
      En los siguientes casos se pasará como argumento el vector data$V2, que es la segunda colummna del dataframe abalone.data y contiene los valores de "length" que se quieren estudiar, así como se usará la función creada **mu_ci(x,dist,n_samples,n_obs,ci)**. Para un mejor análisis de los resultados, se realizarán 100 ejecuciones donde en cada una de ellas se muestrea 10000 veces, con el fin de sacarle un promedio a las fracciones y comparar resultados, ya que cada ejecución que se haga varía un poco los resultados de la fracción deseada. También se dejará un comentario donde se evidencie como se puede hacer una sola ejecución del muestreo.

(a) Extraiga 10000 muestras, cada una de 20 registros (observaciones) de forma aleatoria con reemplazo. Use cada muestra para calcular un intervalo de confianza del 90% para estimar la media poblacional. Use la distribución t para calcular ese intervalo. Recuerde que para realizar el cálculo se desconoce la varianza poblacional ¿Para qué fracción de las muestras la verdadera media poblacional se encuentra dentro del intervalo de confianza definido?

```{r}
  prom=0
  for (i in 1:100)
  {
    a=mu_ci(data$V2,'t',10000,20,0.9)
    prom=prom+a/100
  }
  prom 
```
      Como se puede observar, en este caso, la fracción de las 10000 muestras donde la verdadera media poblacional se encuentra dentro del intervalo de confianza del 90%, siguiendo una distribución t de Student (considerando que esta es la recomendada para casos en que la cantidad de observaciones es menor a 30) y teniendo cada una de ellas 20 registros es cercano al 0.9, y al ejecutarlo varias veces se puede observar que efectivamente, en promedio, dicha fracción tendrá un valor de muy cercano a 0.9, que es 0.896381.

(b) Extraiga 10000 muestras, cada una de 10 registros (observaciones) de forma aleatoria con reemplazo. Use cada muestra para calcular un intervalo de confianza del 90% para estimar la media poblacional. Use la distribución t para calcular ese intervalo. Recuerde que para realizar el cálculo se desconoce la varianza poblacional ¿Para qué fracción de las muestras la verdadera media poblacional se encuentra dentro del intervalo de confianza definido?
```{r}
  prom=0
  for (i in 1:100)
  {
    b=mu_ci(data$V2,'t',10000,10,0.9)
    prom=prom+b/100
  }
  prom
```
      Este caso difiere del anterior solo en la cantidad de observaciones que tiene cada una de las 10000 muestras, reduciendo dicha cantidad a la mitad, aunque ello no parece variar en gran medida la fracción de muestras donde la media poblaciones se encuentra dentro de dicho intervalo de confianza de 0.9 pero si reduce un poco su promedio, ya que llega hasta 0.891712, bajando 0.004669, al realizar 100 ejecuciones. 

(c) Extraiga 10000 muestras, cada una de 10 registros (observaciones) de forma aleatoria con reemplazo. Use cada muestra para calcular un intervalo de confianza del 90% para estimar la media poblacional. Use una distribución normal (que NO se debería usar porque la muestra es demasiado pequeña!). Recuerde que para realizar el cálculo se desconoce la varianza poblacional ¿Para qué fracción de las muestras la verdadera media poblacional se encuentra dentro del intervalo de confianza definido?
```{r}
  prom=0
  for (i in 1:100)
  {
    c=mu_ci(data$V2,'n',10000,10,0.9)
    prom=prom+c/100
  }
  prom
```
      Teniendo en cuenta que para una cantidad de observaciones menor a 30 no es recomendable hacer uso de una distribución normal, se puede observar que la fracción de muestras donde la media poblacional se encuentra dentro del intervalo de confianza tiene un valor cercano al esperado de 0.9, aunque al realizar varias iteraciones su valor promedio es incluso menor que en los casos anteriores, como era de esperarse, y dicho valor es 0.861619, 0.000093 por debajo del caso de la distribución t de Student.

(d) Extraiga 10000 muestras, cada una de 3 registros (observaciones) de forma aleatoria con reemplazo. Use cada muestra para calcular un intervalo de confianza del 90% para estimar la media poblacional. Use la distribución t para calcular ese intervalo. Recuerde que para realizar el cálculo se desconoce la varianza poblacional ¿Para qué fracción de las muestras la verdadera media poblacional se encuentra dentro del intervalo de confianza definido?
```{r}
  prom=0
  for (i in 1:100)
  {
    d=mu_ci(data$V2,'t',10000,3,0.9)
    prom=prom+d/100
  }
  prom
```
      Al disminuir aún más la cantidad de observaciones por cada muestra, es normal que la fracción esperada se aleje más del 0.9 deseado, pues es poco probable que las 3 observaciones de cada muestra sean significativas teniendo una población de 4177, y que su selección fue de manera aleatoria con reemplazo. Dicha fracción tiene un valor promedio de 0.879232 considerando 100 ejecuciones, baja 0.01248 con respecto al caso de 10 observaciones y distribución t de Student (b).

(e) Extraiga 10000 muestras, cada una de 3 registros (observaciones) de forma aleatoria con reemplazo. Use cada muestra para calcular un intervalo de confianza del 90% para estimar la media poblacional. Use una distribución normal (que NO se debería usar porque la muestra es demasiado pequeña!). Recuerde que para realizar el cálculo se desconoce la varianza poblacional ¿Para qué fracción de las muestras la verdadera media poblacional se encuentra dentro del intervalo de confianza definido?
```{r}
  prom=0
  for (i in 1:100)
  {
    e=mu_ci(data$V2,'n',10000,3,0.9)
    prom=prom+e/100
  }
  prom
```
    Se esperaba que este caso obtuviera los peores resultados posibles, ya que se usa una distribución normal cuando no se debería y la cantidad de observaciones por muestra es muy bajita, el valor de la fracción a analizar para 100 iteraciones es, en promedio, 0.878885, si se analiza con respecto al caso inmediatamente anterior (3 observaciones y t de Student) se observa un decremento de 0.000347, y si se compara con el caso de 10 observaciones y también distribución normal, en promedio, disminuye 0.012734.
## 4. Conclusiones
